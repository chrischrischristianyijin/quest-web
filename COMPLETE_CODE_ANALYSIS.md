# Quest Web App - Complete Code Analysis for Data Persistence Issue

## Problem Summary
**Issue**: Insights and stacks disappear after page refresh despite localStorage backup implementation.

## Complete Code Files

### 1. Main Application Logic
**File**: `src/client/js/my-space.js`

```javascript
import { auth } from './auth.js';
import { api } from './api.js';
import { API_CONFIG } from './config.js';
import { PATHS, navigateTo } from './paths.js';

// DOM Element Cache for Performance Optimization
const DOM_CACHE = new Map();

function getCachedElement(selector) {
    if (!DOM_CACHE.has(selector)) {
        const element = document.querySelector(selector);
        if (element) {
            DOM_CACHE.set(selector, element);
        }
    }
    return DOM_CACHE.get(selector);
}

function getCachedElementById(id) {
    const selector = `#${id}`;
    if (!DOM_CACHE.has(selector)) {
        const element = document.getElementById(id);
        if (element) {
            DOM_CACHE.set(selector, element);
        }
    }
    return DOM_CACHE.get(selector);
}

// DOM ÂÖÉÁ¥† - Using cached access for better performance
const profileAvatar = getCachedElementById('profileAvatar');
const usernamePlaceholder = getCachedElementById('usernamePlaceholder');
const contentCards = getCachedElementById('contentCards');
const headerLogout = getCachedElementById('headerLogout');
const headerEditProfile = getCachedElementById('headerEditProfile');
const headerAvatar = getCachedElementById('headerAvatar');
const addContentForm = getCachedElementById('addContentForm');
const addContentModal = getCachedElementById('addContentModal');
const closeAddModal = getCachedElementById('closeAddModal');
const cancelAddBtn = getCachedElementById('cancelAddBtn');

const filterButtons = getCachedElementById('filterButtons');

// È°µÈù¢Áä∂ÊÄÅ
let currentUser = null;
let currentInsights = [];
let currentFilters = {
    latest: 'latest',  // Êó∂Èó¥ÊéíÂ∫è
    tags: null         // Ê†áÁ≠æÁ≠õÈÄâ
};
let isEditMode = false; // Edit mode state
let draggedCard = null;
let dragOffset = { x: 0, y: 0 };
let stackHoverTimeout = null;
let stacks = new Map(); // Store stacks data
let stackIdCounter = 1;

// È°µÈù¢ÂàùÂßãÂåñ
async function initPage() {
    try {
        console.log('üöÄ ÂàùÂßãÂåñMy SpaceÈ°µÈù¢...');
        console.log('üîç Debug: auth module available:', typeof auth);
        console.log('üîç Debug: api module available:', typeof api);
        
        // ÊÅ¢Â§ç‰ºöËØùÁä∂ÊÄÅ
        try {
            auth.restoreSession();
            console.log('‚úÖ Session restore completed');
        } catch (sessionError) {
            console.error('‚ùå Session restore failed:', sessionError);
        }
        
        // Ê£ÄÊü•ËÆ§ËØÅÁä∂ÊÄÅÔºàÊîæÂÆΩÔºöÂÖàÂ∞ùËØïÊÅ¢Â§ç‰ºöËØùÂêéÂÜçÂà§Êñ≠ÔºåÈÅøÂÖçÈó™Ë∑≥Ôºâ
        console.log('üîç Debug: Checking auth status...');
        const isAuthenticated = auth.checkAuth();
        console.log('üîç Debug: Auth status:', isAuthenticated);
        
        if (!isAuthenticated) {
            console.log('‚ö†Ô∏è Êú™Ê£ÄÊµãÂà∞‰ºöËØùÔºåÂ∞ùËØïÊÅ¢Â§ç...');
            const restored = auth.restoreSession();
            console.log('üîç Debug: Session restoration result:', restored);
            
            if (!restored) {
                console.log('‚ùå Êó†‰ºöËØùÂèØÊÅ¢Â§çÔºå‰øùÊåÅÂú®ÂΩìÂâçÈ°µÂπ∂ÊèêÁ§∫ÁôªÂΩï');
                showErrorMessage('Please sign in to use My Space.');
                
                // Âç≥‰ΩøÊú™ËÆ§ËØÅÔºå‰πüÁªëÂÆöÂü∫Á°ÄUI‰∫ã‰ª∂ÔºàÂ¶ÇÁî®Êà∑ËµÑÊñôÁºñËæëÔºâ
                console.log('üîß Êú™ËÆ§ËØÅÁä∂ÊÄÅ‰∏ãÁªëÂÆöÂü∫Á°ÄUI‰∫ã‰ª∂...');
                bindProfileEditEvents();
                
                return;
            }
        }
        
        // Ê£ÄÊü•tokenÊòØÂê¶ËøáÊúüÔºàÊîæÂÆΩÔºö‰∏çËøáÊúü‰πüÂÖÅËÆ∏ÁªßÁª≠Âä†ËΩΩÂü∫Á°ÄUIÔºâ
        const tokenOk = await auth.checkAndHandleTokenExpiration();
        if (!tokenOk) {
            console.log('‚è∞ TokenÊ†°È™åÂ§±Ë¥•ÔºåÁªßÁª≠‰ª•ÈôçÁ∫ßÊ®°ÂºèÂä†ËΩΩMy Space UI');
        }
        
        console.log('‚úÖ ËÆ§ËØÅÁä∂ÊÄÅÊ≠£Â∏∏ÔºåÁªßÁª≠ÂàùÂßãÂåñ...');
        
        // Âπ∂Ë°åÂä†ËΩΩÊâÄÊúâÊï∞ÊçÆ‰ª•ÊèêÈ´òÊÄßËÉΩ
        const [profileResult, insightsResult, tagsResult, stacksResult] = await Promise.allSettled([
            loadUserProfile(),
            loadUserInsights(),
            loadUserTags(),
            loadUserStacks()
        ]);
        
        // Ê£ÄÊü•ÊØè‰∏™Âä†ËΩΩÁªìÊûúÂπ∂ËÆ∞ÂΩïÈîôËØØ
        if (profileResult.status === 'rejected') {
            console.error('‚ùå Áî®Êà∑ËµÑÊñôÂä†ËΩΩÂ§±Ë¥•:', profileResult.reason);
        }
        if (stacksResult.status === 'rejected') {
            console.error('‚ùå Áî®Êà∑stacksÂä†ËΩΩÂ§±Ë¥•:', stacksResult.reason);
        }
        if (insightsResult.status === 'rejected') {
            console.error('‚ùå Áî®Êà∑insightsÂä†ËΩΩÂ§±Ë¥•:', insightsResult.reason);
        }
        if (tagsResult.status === 'rejected') {
            console.error('‚ùå Áî®Êà∑Ê†áÁ≠æÂä†ËΩΩÂ§±Ë¥•:', tagsResult.reason);
        }
        
        // ÂàùÂßãÂåñËøáÊª§Âô®ÊåâÈíÆ
        initFilterButtons();
        
        // ÁªëÂÆö‰∫ã‰ª∂
        bindEvents();
        
        // ÁªëÂÆöÁºñËæëÊ®°ÂºèÊåâÈíÆ‰∫ã‰ª∂
        bindEditModeEvents();
        
        // Set up event delegation for card interactions (performance optimization)
        setupCardEventDelegation();
        
        console.log('‚úÖ My SpaceÈ°µÈù¢ÂàùÂßãÂåñÂÆåÊàê');
    } catch (error) {
        console.error('‚ùå È°µÈù¢ÂàùÂßãÂåñÂ§±Ë¥•:', error);
        
        // Â¶ÇÊûúÊòØËÆ§ËØÅÈîôËØØÔºåÈáçÂÆöÂêëÂà∞ÁôªÂΩïÈ°µÈù¢
        if (error.message.includes('ËÆ§ËØÅÂ∑≤ËøáÊúü') || error.message.includes('ËØ∑ÈáçÊñ∞ÁôªÂΩï')) {
            window.location.href = PATHS.LOGIN;
            return;
        }
        
        showErrorMessage('È°µÈù¢ÂàùÂßãÂåñÂ§±Ë¥•ÔºåËØ∑Âà∑Êñ∞ÈáçËØï');
    }
}

// Âä†ËΩΩÁî®Êà∑stacks
async function loadUserStacks() {
    try {
        console.log('üìö ÂºÄÂßãÂä†ËΩΩÁî®Êà∑stacks...');
        
        // Ê£ÄÊü•ËÆ§ËØÅÁä∂ÊÄÅ
        if (!auth.checkAuth()) {
            console.warn('‚ö†Ô∏è Áî®Êà∑Êú™ËÆ§ËØÅÔºåË∑≥ËøástacksÂä†ËΩΩ');
            return;
        }
        
        try {
            // Load all insights and group them by stack_id
            const response = await api.getInsights();
            
            console.log('üîç Stack loading API response:', response);
            
            if (response.success && response.data) {
                // Handle different response structures
                let allInsights;
                if (Array.isArray(response.data)) {
                    allInsights = response.data;
                } else if (response.data.insights && Array.isArray(response.data.insights)) {
                    allInsights = response.data.insights;
                } else if (response.data.data && Array.isArray(response.data.data)) {
                    allInsights = response.data.data;
                } else {
                    console.warn('‚ö†Ô∏è Unexpected API response structure:', response.data);
                    allInsights = [];
                }
                
                stacks.clear(); // Ê∏ÖÁ©∫Áé∞Êúâstacks
                
                console.log('üîç All insights loaded:', allInsights.length);
                console.log('üîç Sample insight fields:', allInsights[0] ? Object.keys(allInsights[0]) : 'No insights');
                console.log('üîç Insights with stack_id:', allInsights.filter(i => i.stack_id));
                
                // Group insights by stack_id
                const stackGroups = {};
                allInsights.forEach(insight => {
                    if (insight.stack_id) {
                        console.log('üîç Found insight with stack_id:', insight.id, '->', insight.stack_id);
                        if (!stackGroups[insight.stack_id]) {
                            stackGroups[insight.stack_id] = [];
                        }
                        stackGroups[insight.stack_id].push(insight);
                    }
                });
                
                // Create stack objects from grouped insights
                Object.entries(stackGroups).forEach(([stackId, stackInsights]) => {
                    if (stackInsights.length >= 2) { // Only create stacks with 2+ items
                        const stackData = {
                            id: stackId,
                            name: 'Stack', // Default name
                            cards: stackInsights,
                            createdAt: stackInsights[0]?.created_at || new Date().toISOString(),
                            modifiedAt: stackInsights[0]?.modified_at || new Date().toISOString(),
                            isExpanded: false
                        };
                        
                        stacks.set(stackId, stackData);
                    }
                });
                
                // Always try to load metadata from localStorage to preserve user preferences
                console.log('üîç Loading stack metadata from localStorage...');
                const savedStacks = localStorage.getItem('quest_stacks');
                if (savedStacks) {
                    try {
                        const stackEntries = JSON.parse(savedStacks);
                        stackEntries.forEach(([stackId, stackData]) => {
                            if (stacks.has(stackId)) {
                                // Merge metadata from localStorage with database data
                                const existingStack = stacks.get(stackId);
                                if (existingStack && stackData.name) {
                                    existingStack.name = stackData.name;
                                    existingStack.isExpanded = stackData.isExpanded || false;
                                    console.log('üîç Merged stack metadata from localStorage:', stackId);
                                }
                            } else {
                                // Load stack from localStorage if not found in database
                                stacks.set(stackId, stackData);
                                console.log('üîç Loaded stack from localStorage:', stackId);
                            }
                        });
                    } catch (error) {
                        console.error('‚ùå Failed to parse saved stacks:', error);
                    }
                }
                
                // If no stacks found in database, try loading from localStorage
                if (Object.keys(stackGroups).length === 0 && stacks.size === 0) {
                    console.log('üîç No stacks found in database or localStorage');
                }
                
                // Êõ¥Êñ∞stackIdCounter
                if (Object.keys(stackGroups).length > 0) {
                    const maxTimestamp = Math.max(...Object.keys(stackGroups).map(id => {
                        const timestamp = id.split('_')[1];
                        return timestamp ? parseInt(timestamp) : 0;
                    }));
                    stackIdCounter = Math.max(stackIdCounter, maxTimestamp + 1);
                }
                
                console.log('‚úÖ Áî®Êà∑stacksÂä†ËΩΩÊàêÂäü:', stacks.size, '‰∏™stacks');
            } else {
                console.warn('‚ö†Ô∏è Ê≤°ÊúâstacksÊï∞ÊçÆÊàñAPIËøîÂõûÊ†ºÂºèÈîôËØØÔºåÂ∞ùËØï‰ªélocalStorageÂä†ËΩΩ');
                // Try loading from localStorage as fallback
                const savedStacks = localStorage.getItem('quest_stacks');
                if (savedStacks) {
                    try {
                        const stackEntries = JSON.parse(savedStacks);
                        stackEntries.forEach(([stackId, stackData]) => {
                            stacks.set(stackId, stackData);
                            console.log('üîç Loaded stack from localStorage:', stackId);
                        });
                    } catch (error) {
                        console.error('‚ùå Failed to parse saved stacks:', error);
                    }
                }
            }
        } catch (apiError) {
            console.error('‚ùå APIË∞ÉÁî®Â§±Ë¥•:', apiError);
            // Â¶ÇÊûúAPIË∞ÉÁî®Â§±Ë¥•ÔºåÁªßÁª≠‰ΩøÁî®Êú¨Âú∞Â≠òÂÇ®
            console.log('üîç API failed, trying localStorage fallback...');
            const savedStacks = localStorage.getItem('quest_stacks');
            if (savedStacks) {
                try {
                    const stackEntries = JSON.parse(savedStacks);
                    stackEntries.forEach(([stackId, stackData]) => {
                        stacks.set(stackId, stackData);
                        console.log('üîç Loaded stack from localStorage:', stackId);
                    });
                } catch (error) {
                    console.error('‚ùå Failed to parse saved stacks:', error);
                }
            }
        }
    } catch (error) {
        console.error('‚ùå Âä†ËΩΩÁî®Êà∑stacksÂ§±Ë¥•:', error);
    }
}

// Âä†ËΩΩÁî®Êà∑ËßÅËß£
async function loadUserInsights() {
    try {
        console.log('üìö ÂºÄÂßãÂä†ËΩΩÁî®Êà∑insights...');
        console.log('üîç Auth status before API call:', auth.checkAuth());
        console.log('üîç Current user:', auth.getCurrentUser());
        
        // ‰ΩøÁî®Êñ∞ÁöÑAPIÊñπÊ≥ïËé∑Âèñinsights
        const response = await api.getInsights();
        
        console.log('üì° APIÂìçÂ∫î:', response);
        console.log('üîç Response structure:', {
            success: response?.success,
            hasData: !!response?.data,
            dataKeys: response?.data ? Object.keys(response.data) : 'no data',
            insightsCount: response?.data?.insights?.length || 0
        });
        
        if (response.success && response.data && response.data.insights) {
            // Filter out insights that are already in stacks
            const allInsights = response.data.insights;
            currentInsights = allInsights.filter(insight => !insight.stack_id);
            console.log('‚úÖ Áî®Êà∑insightsÂä†ËΩΩÊàêÂäü:', allInsights.length, 'Êù°');
            console.log('üìö ËøáÊª§ÊéâÂ∑≤Âú®stacks‰∏≠ÁöÑinsightsÂêé:', currentInsights.length, 'Êù°');
            
            // Save insights to localStorage as backup with timestamp
            try {
                const insightsBackup = {
                    data: currentInsights,
                    timestamp: Date.now(),
                    version: '1.0'
                };
                localStorage.setItem('quest_insights_backup', JSON.stringify(insightsBackup));
                console.log('üíæ Insights saved to localStorage backup');
            } catch (storageError) {
                console.warn('‚ö†Ô∏è Failed to save insights to localStorage:', storageError);
            }
            
            // Ê£ÄÊü•ÊØè‰∏™insightÁöÑÊ†áÁ≠æÊï∞ÊçÆ
            currentInsights.forEach((insight, index) => {
                console.log(`üìñ Insight ${index + 1}:`, {
                    id: insight.id,
                    title: insight.title || insight.url,
                    tags: insight.tags,
                    tagsType: typeof insight.tags,
                    tagsLength: insight.tags ? insight.tags.length : 'null/undefined',
                    tagIds: insight.tag_ids,
                    allFields: Object.keys(insight)
                });
                
                // ËØ¶ÁªÜÊ£ÄÊü•Ê†áÁ≠æÊï∞ÊçÆÁªìÊûÑ
                if (insight.tags && insight.tags.length > 0) {
                    insight.tags.forEach((tag, tagIndex) => {
                        console.log(`  üè∑Ô∏è Tag ${tagIndex + 1}:`, {
                            tag: tag,
                            type: typeof tag,
                            isObject: tag && typeof tag === 'object',
                            hasId: tag && tag.id,
                            hasName: tag && tag.name
                        });
                    });
                }
            });
            
            // Normalize tag structure for all insights first
            currentInsights.forEach(insight => {
                if (insight.tags && insight.tags.length > 0) {
                    // Normalize tag structure - backend returns {tag_id, name, color}, frontend expects {id, name, color}
                    insight.tags = insight.tags.map(tag => ({
                        id: tag.tag_id || tag.id,
                        name: tag.name,
                        color: tag.color
                    }));
                }
            });
            
            // Check if insights have tags, if not, try to load them separately
            const insightsWithoutTags = currentInsights.filter(insight => !insight.tags || insight.tags.length === 0);
            if (insightsWithoutTags.length > 0) {
                console.log('‚ö†Ô∏è Found insights without tags, attempting to load tags separately...');
                await loadTagsForInsights(insightsWithoutTags);
            }
            
            renderInsights();
        } else {
            console.warn('‚ö†Ô∏è APIËøîÂõûÊ†ºÂºè‰∏çÊ≠£Á°Æ:', response);
            console.log('üîç ÂìçÂ∫îÊï∞ÊçÆÁªìÊûÑ:', {
                success: response.success,
                hasData: !!response.data,
                dataKeys: response.data ? Object.keys(response.data) : 'no data',
                insightsField: response.data ? response.data.insights : 'no insights field'
            });
            
            // Try loading from localStorage backup
            console.log('üì¶ Attempting to load insights from localStorage backup...');
            const backupInsights = localStorage.getItem('quest_insights_backup');
            if (backupInsights) {
                try {
                    const backup = JSON.parse(backupInsights);
                    // Check if backup is recent (within 24 hours)
                    const isRecent = backup.timestamp && (Date.now() - backup.timestamp < 24 * 60 * 60 * 1000);
                    if (isRecent && backup.data) {
                        currentInsights = backup.data;
                        console.log('üì¶ Loaded recent insights from localStorage backup:', currentInsights.length);
                    } else {
                        console.log('üì¶ Backup is too old or invalid, using empty array');
                        currentInsights = [];
                    }
                } catch (error) {
                    console.error('‚ùå Failed to parse backup insights:', error);
                    currentInsights = [];
                }
            } else {
                currentInsights = [];
            }
            renderInsights();
        }
    } catch (error) {
        console.error('‚ùå Âä†ËΩΩÁî®Êà∑insightsÂ§±Ë¥•:', error);
        
        // Try loading from localStorage backup before showing error
        console.log('üì¶ Attempting to load insights from localStorage backup after error...');
        const backupInsights = localStorage.getItem('quest_insights_backup');
        if (backupInsights) {
            try {
                const backup = JSON.parse(backupInsights);
                // Check if backup is recent (within 24 hours)
                const isRecent = backup.timestamp && (Date.now() - backup.timestamp < 24 * 60 * 60 * 1000);
                if (isRecent && backup.data) {
                    currentInsights = backup.data;
                    console.log('üì¶ Loaded recent insights from localStorage backup after error:', currentInsights.length);
                    renderInsights();
                    return; // Don't show error if we successfully loaded from backup
                } else {
                    console.log('üì¶ Backup is too old or invalid after error, using empty array');
                    currentInsights = [];
                }
            } catch (parseError) {
                console.error('‚ùå Failed to parse backup insights:', parseError);
                currentInsights = [];
            }
        } else {
            currentInsights = [];
        }
        
        // Ê£ÄÊü•ÊòØÂê¶ÊòØÂêéÁ´ØÊúçÂä°ÈóÆÈ¢ò
        if (error.message.includes('500') || error.message.includes('Internal Server Error')) {
            showErrorMessage('Backend service temporarily unavailable. Please try again later.');
        } else if (error.message.includes('401') || error.message.includes('403')) {
            showErrorMessage('Authentication failed. Please log in again.');
            // ÈáçÂÆöÂêëÂà∞ÁôªÂΩïÈ°µÈù¢
            setTimeout(() => {
                window.location.href = PATHS.LOGIN;
            }, 2000);
        } else {
            showErrorMessage('Failed to load insights. Please refresh and try again.');
        }
        
        renderInsights();
    }
}

// Save stacks to localStorage (called periodically to prevent data loss)
function saveStacksToLocalStorage() {
    try {
        const stacksData = Array.from(stacks.entries());
        localStorage.setItem('quest_stacks', JSON.stringify(stacksData));
        console.log('üíæ Saved stacks to localStorage:', stacksData.length, 'stacks');
    } catch (error) {
        console.error('‚ùå Failed to save stacks to localStorage:', error);
    }
}

// Save insights to localStorage backup
function saveInsightsToLocalStorage() {
    try {
        const insightsBackup = {
            data: currentInsights,
            timestamp: Date.now(),
            version: '1.0'
        };
        localStorage.setItem('quest_insights_backup', JSON.stringify(insightsBackup));
        console.log('üíæ Saved insights to localStorage backup:', currentInsights.length, 'insights');
    } catch (error) {
        console.error('‚ùå Failed to save insights to localStorage:', error);
    }
}

// Auto-save stacks and insights every 30 seconds to prevent data loss
setInterval(() => {
    saveStacksToLocalStorage();
    saveInsightsToLocalStorage();
}, 30000);

// È°µÈù¢Âä†ËΩΩÂÆåÊàêÂêéÂàùÂßãÂåñ
document.addEventListener('DOMContentLoaded', initPage);
```

### 2. Authentication Management
**File**: `src/client/js/auth.js`

```javascript
import { api } from './api.js';

// Áî®Êà∑Áä∂ÊÄÅÁÆ°ÁêÜ
class AuthManager {
    constructor() {
        this.user = null;
        this.isAuthenticated = false;
        this.listeners = [];
        this.init();
    }

    // ÂàùÂßãÂåñ
    init() {
        // Ê£ÄÊü•Êú¨Âú∞Â≠òÂÇ®ÁöÑÁî®Êà∑‰ºöËØù
        const session = localStorage.getItem('quest_user_session');
        if (session) {
            try {
                const parsed = JSON.parse(session);
                if (parsed.user && parsed.timestamp) {
                    // Ê£ÄÊü•‰ºöËØùÊòØÂê¶ËøáÊúüÔºà24Â∞èÊó∂Ôºâ
                    const now = Date.now();
                    if (now - parsed.timestamp < 24 * 60 * 60 * 1000) {
                        this.user = parsed.user;
                        this.isAuthenticated = true;
                        this.notifyListeners();
                    } else {
                        // ‰ºöËØùËøáÊúüÔºåÊ∏ÖÈô§
                        this.clearSession();
                    }
                }
            } catch (error) {
                console.error('Ëß£ÊûêÁî®Êà∑‰ºöËØùÂ§±Ë¥•:', error);
                this.clearSession();
            }
        }
    }

    // Áî®Êà∑ÁôªÂΩï
    async login(email, password) {
        try {
            console.log('üîê ÂºÄÂßãÁôªÂΩïÊµÅÁ®ã...', { email });
            const result = await api.login({ email, password });
            console.log('üì° API ÂìçÂ∫îÁªìÊûú:', result);
            
            if (result && result.success && result.user) {
                console.log('‚úÖ ÁôªÂΩïÊàêÂäüÔºåËé∑ÂèñÂà∞ token:', result.token);
                
                // ËÆæÁΩÆËÆ§ËØÅ token
                api.setAuthToken(result.token);
                
                // Ëé∑ÂèñÂÆåÊï¥ÁöÑÁî®Êà∑ËµÑÊñô
                try {
                    console.log('üîç Ëé∑ÂèñÁî®Êà∑ÂÆåÊï¥ËµÑÊñô...');
                    const profileResult = await api.getUserProfile();
                    console.log('üì° Áî®Êà∑ËµÑÊñô API ÂìçÂ∫î:', profileResult);
                    
                    if (profileResult && profileResult.success && profileResult.data) {
                        this.user = profileResult.data;
                        console.log('‚úÖ Ëé∑ÂèñÂà∞ÂÆåÊï¥Áî®Êà∑‰ø°ÊÅØ:', this.user);
                        // Êõ¥Êñ∞Êú¨Âú∞Â≠òÂÇ®ÁöÑ‰ºöËØùÊï∞ÊçÆ
                        this.saveSession(this.user, result.token);
                    } else {
                        // Â¶ÇÊûúËé∑ÂèñËµÑÊñôÂ§±Ë¥•ÔºåÂ∞ùËØï‰ΩøÁî®‰∏çÂêåÁöÑÂìçÂ∫îÊ†ºÂºè
                        console.warn('‚ö†Ô∏è Ëé∑ÂèñÁî®Êà∑ËµÑÊñôÂ§±Ë¥•ÔºåÂ∞ùËØïÂÖ∂‰ªñÂìçÂ∫îÊ†ºÂºè');
                        console.warn('‚ö†Ô∏è Profile API response structure:', {
                            hasSuccess: !!profileResult?.success,
                            hasData: !!profileResult?.data,
                            fullResponse: profileResult
                        });
                        
                        // Â∞ùËØïÁõ¥Êé•‰ΩøÁî® profileResult ‰Ωú‰∏∫Áî®Êà∑Êï∞ÊçÆÔºàÊüê‰∫õAPIÂèØËÉΩÁõ¥Êé•ËøîÂõûÁî®Êà∑Êï∞ÊçÆÔºâ
                        if (profileResult && (profileResult.id || profileResult.email)) {
                            console.log('‚úÖ ‰ΩøÁî®Áõ¥Êé•ËøîÂõûÁöÑÁî®Êà∑Êï∞ÊçÆ');
                            this.user = profileResult;
                            // Êõ¥Êñ∞Êú¨Âú∞Â≠òÂÇ®ÁöÑ‰ºöËØùÊï∞ÊçÆ
                            this.saveSession(this.user, result.token);
                        } else {
                            // ÊúÄÂêéÂõûÈÄÄÂà∞ÁôªÂΩïËøîÂõûÁöÑÂü∫Êú¨‰ø°ÊÅØ
                            console.warn('‚ö†Ô∏è ‰ΩøÁî®Âü∫Êú¨ÁôªÂΩï‰ø°ÊÅØ‰Ωú‰∏∫ÂõûÈÄÄ');
                            this.user = result.user;
                        }
                    }
                } catch (profileError) {
                    console.warn('‚ö†Ô∏è Ëé∑ÂèñÁî®Êà∑ËµÑÊñôÊó∂Âá∫ÈîôÔºå‰ΩøÁî®Âü∫Êú¨ÁôªÂΩï‰ø°ÊÅØ:', profileError);
                    console.warn('‚ö†Ô∏è Profile API error details:', {
                        error: profileError.message,
                        stack: profileError.stack
                    });
                    this.user = result.user;
                }
                
                this.isAuthenticated = true;
                
                // ‰øùÂ≠òÁî®Êà∑‰ºöËØù
                this.saveSession(this.user, result.token);
                
                this.notifyListeners();
                return { success: true, user: this.user };
            } else {
                throw new Error(result?.message || 'ÁôªÂΩïÂ§±Ë¥•');
            }
        } catch (error) {
            console.error('‚ùå ÁôªÂΩïÂ§±Ë¥•:', error);
            return { success: false, message: error.message || 'ÁôªÂΩïÂ§±Ë¥•ÔºåËØ∑ÈáçËØï' };
        }
    }

    // Áî®Êà∑ÁôªÂá∫
    async logout() {
        try {
            console.log('üö™ ÂºÄÂßãÁî®Êà∑ÁôªÂá∫ÊµÅÁ®ã...');
            
            // Áõ¥Êé•Ê∏ÖÈô§Êú¨Âú∞Áä∂ÊÄÅÔºå‰∏çÈúÄË¶ÅË∞ÉÁî®ÂêéÁ´ØAPI
            this.clearSession();
            this.notifyListeners();
            
            console.log('‚úÖ ÁôªÂá∫ÊàêÂäü');
            return { success: true };
            
        } catch (error) {
            console.error('‚ùå ÁôªÂá∫ÈîôËØØ:', error);
            // Âç≥‰ΩøÂá∫ÈîôÔºå‰πüË¶ÅÊ∏ÖÈô§Êú¨Âú∞‰ºöËØù
            this.clearSession();
            this.notifyListeners();
            return { success: false, message: error.message };
        }
    }

    // ‰øùÂ≠òÁî®Êà∑‰ºöËØù
    saveSession(user, token) {
        if (token) {
            // Âè™Âú®‰∏Ä‰∏™Âú∞ÊñπÂ≠òÂÇ®tokenÔºöquest_user_session
            api.setAuthToken(token);
        }
        
        localStorage.setItem('quest_user_session', JSON.stringify({
            user,
            token: token,
            timestamp: Date.now()
        }));
        
        console.log('üíæ ‰ºöËØùÂ∑≤‰øùÂ≠ò:', { 
            user: user.email || user.username, 
            hasToken: !!token,
            sessionToken: !!localStorage.getItem('quest_user_session')
        });
    }

    // Ê∏ÖÈô§Áî®Êà∑‰ºöËØù
    clearSession() {
        console.log('üóëÔ∏è ÂºÄÂßãÊ∏ÖÁêÜÁî®Êà∑‰ºöËØù...');
        
        // Ê∏ÖÈô§Áî®Êà∑Áä∂ÊÄÅ
        this.user = null;
        this.isAuthenticated = false;
        
        // Ê∏ÖÈô§ÊâÄÊúâtokenÂ≠òÂÇ®
        api.setAuthToken(null);
        localStorage.removeItem('quest_user_session');
        localStorage.removeItem('authToken'); // Ê∏ÖÁêÜÂèØËÉΩÂ≠òÂú®ÁöÑÊóßÂ≠òÂÇ®
        
        // Ê∏ÖÈô§ÂÖ∂‰ªñÂèØËÉΩÂ≠òÂú®ÁöÑÁõ∏ÂÖ≥Â≠òÂÇ®
        localStorage.removeItem('quest_user_profile');
        localStorage.removeItem('quest_user_insights');
        
        console.log('‚úÖ ‰ºöËØùÂ∑≤ÂÆåÂÖ®Ê∏ÖÈô§');
    }

    // Ëé∑ÂèñÂΩìÂâçÁî®Êà∑
    getCurrentUser() {
        return this.user;
    }

    // Ê£ÄÊü•ÊòØÂê¶Â∑≤ËÆ§ËØÅ
    checkAuth() {
        return this.isAuthenticated;
    }

    // ËÆ¢ÈòÖÁä∂ÊÄÅÂèòÂåñ
    subscribe(listener) {
        this.listeners.push(listener);
        // Á´ãÂç≥Ë∞ÉÁî®‰∏ÄÊ¨°
        listener(this);
        
        return () => {
            const index = this.listeners.indexOf(listener);
            if (index > -1) {
                this.listeners.splice(index, 1);
            }
        };
    }

    // ÈÄöÁü•ÁõëÂê¨Âô®
    notifyListeners() {
        this.listeners.forEach(listener => {
            try {
                listener(this);
            } catch (error) {
                console.error('Áä∂ÊÄÅÁõëÂê¨Âô®ÈîôËØØ:', error);
            }
        });
    }
    
    // ÊÅ¢Â§ç‰ºöËØùÁä∂ÊÄÅ
    restoreSession() {
        try {
            console.log('üîÑ ÂºÄÂßãÊÅ¢Â§ç‰ºöËØùÁä∂ÊÄÅ...');
            const sessionData = localStorage.getItem('quest_user_session');
            console.log('üì¶ ‰ºöËØùÊï∞ÊçÆ:', sessionData ? 'Â≠òÂú®' : '‰∏çÂ≠òÂú®');
            
            if (sessionData) {
                const session = JSON.parse(sessionData);
                console.log('üîç Ëß£ÊûêÁöÑ‰ºöËØùÊï∞ÊçÆ:', {
                    hasUser: !!session.user,
                    hasToken: !!session.token,
                    timestamp: session.timestamp
                });
                
                const now = Date.now();
                const sessionAge = now - session.timestamp;
                
                // Ê£ÄÊü•‰ºöËØùÊòØÂê¶ËøáÊúüÔºà24Â∞èÊó∂Ôºâ
                console.log('üîç ‰ºöËØùÂπ¥ÈæÑÊ£ÄÊü•:', {
                    sessionAge: sessionAge,
                    sessionAgeHours: sessionAge / (1000 * 60 * 60),
                    maxAge: 24 * 60 * 60 * 1000,
                    maxAgeHours: 24,
                    isExpired: sessionAge >= 24 * 60 * 60 * 1000,
                    sessionTimestamp: session.timestamp,
                    currentTime: now,
                    timeDiff: now - session.timestamp
                });
                
                if (sessionAge < 24 * 60 * 60 * 1000) {
                    console.log('üîÑ ÊÅ¢Â§ç‰ºöËØùÁä∂ÊÄÅ...');
                    this.user = session.user;
                    this.isAuthenticated = true;
                    
                    // ÊÅ¢Â§ç token - Âè™‰ªé quest_user_session ÊÅ¢Â§ç
                    if (session.token) {
                        console.log('üîë ‰ªé‰ºöËØùÊÅ¢Â§ç token...');
                        api.setAuthToken(session.token);
                        console.log('‚úÖ TokenÊÅ¢Â§çÊàêÂäüÔºåÂΩìÂâçAPI tokenÁä∂ÊÄÅ:', api.authToken ? 'Â∑≤ËÆæÁΩÆ' : 'Êú™ËÆæÁΩÆ');
                    } else {
                        console.log('‚ö†Ô∏è ‰ºöËØù‰∏≠Ê≤°ÊúâtokenÔºåÊ∏ÖÈô§‰ºöËØù');
                        this.clearSession();
                        return false;
                    }
                    
                    this.notifyListeners();
                    return true;
                } else {
                    console.log('‚è∞ ‰ºöËØùÂ∑≤ËøáÊúü');
                    this.clearSession();
                    return false;
                }
            } else {
                console.log('üì¶ Ê≤°ÊúâÊâæÂà∞‰ºöËØùÊï∞ÊçÆ');
                return false;
            }
        } catch (error) {
            console.error('‚ùå ÊÅ¢Â§ç‰ºöËØùÁä∂ÊÄÅÂ§±Ë¥•:', error);
            this.clearSession();
            return false;
        }
    }

    // È™åËØÅtokenÊòØÂê¶ÊúâÊïà
    async validateToken() {
        try {
            if (!this.isAuthenticated || !this.user) {
                console.log('‚ö†Ô∏è Áî®Êà∑Êú™ËÆ§ËØÅÔºåÊó†Ê≥ïÈ™åËØÅtoken');
                return false;
            }
            
            // Â∞ùËØïËé∑ÂèñÁî®Êà∑ËµÑÊñôÊù•È™åËØÅtoken
            const profileResult = await api.getUserProfile();
            if (profileResult && profileResult.success) {
                console.log('‚úÖ TokenÈ™åËØÅÊàêÂäü');
                return true;
            } else {
                console.log('‚ùå TokenÈ™åËØÅÂ§±Ë¥•');
                return false;
            }
        } catch (error) {
            console.error('‚ùå TokenÈ™åËØÅÂá∫Èîô:', error);
            if (error.message.includes('401') || error.message.includes('403')) {
                console.log('üîë TokenÂ∑≤ËøáÊúüÔºåÊ∏ÖÈô§‰ºöËØù');
                this.clearSession();
            }
            return false;
        }
    }
    
    // Ëé∑ÂèñÂΩìÂâçtoken
    getCurrentToken() {
        try {
            const sessionData = localStorage.getItem('quest_user_session');
            if (sessionData) {
                const session = JSON.parse(sessionData);
                return session.token || null;
            }
            return null;
        } catch (error) {
            console.error('Ëé∑ÂèñtokenÂ§±Ë¥•:', error);
            return null;
        }
    }
    
    // Ê£ÄÊü•tokenÊòØÂê¶Â≠òÂú®
    hasValidToken() {
        const token = this.getCurrentToken();
        return !!token;
    }

    // Ê£ÄÊü•tokenÊòØÂê¶ËøáÊúü
    isTokenExpired() {
        const session = localStorage.getItem('quest_user_session');
        if (!session) return true;
        
        try {
            const parsed = JSON.parse(session);
            if (!parsed.timestamp) return true;
            
            const now = Date.now();
            const sessionAge = now - parsed.timestamp;
            
            // 24Â∞èÊó∂ËøáÊúü
            return sessionAge >= 24 * 60 * 60 * 1000;
        } catch (error) {
            console.error('Ê£ÄÊü•tokenËøáÊúüÂ§±Ë¥•:', error);
            return true;
        }
    }

    // Âà∑Êñ∞tokenÔºàÂ¶ÇÊûúÈúÄË¶ÅÁöÑËØùÔºâ
    async refreshToken() {
        try {
            console.log('üîÑ Â∞ùËØïÂà∑Êñ∞token...');
            
            // Ê£ÄÊü•ÊòØÂê¶ÊúâÊúâÊïàÁöÑ‰ºöËØù
            if (!this.isAuthenticated || !this.user) {
                throw new Error('Ê≤°ÊúâÊúâÊïàÁöÑ‰ºöËØùÂèØ‰ª•Âà∑Êñ∞');
            }
            
            // ËøôÈáåÂèØ‰ª•Ë∞ÉÁî®ÂêéÁ´ØÂà∑Êñ∞tokenÁöÑAPI
            // ÁõÆÂâçÂêéÁ´ØÊ≤°ÊúâÊèê‰æõÂà∑Êñ∞tokenÁöÑÊé•Âè£ÔºåÊâÄ‰ª•Áõ¥Êé•ËøîÂõûfalse
            console.log('‚ö†Ô∏è ÂêéÁ´ØÊöÇ‰∏çÊîØÊåÅtokenÂà∑Êñ∞');
            return false;
        } catch (error) {
            console.error('Âà∑Êñ∞tokenÂ§±Ë¥•:', error);
            return false;
        }
    }

    // Ê£ÄÊü•Âπ∂Â§ÑÁêÜtokenËøáÊúü
    async checkAndHandleTokenExpiration() {
        if (this.isTokenExpired()) {
            console.log('‚è∞ TokenÂ∑≤ËøáÊúüÔºåÂ∞ùËØïÂà∑Êñ∞...');
            
            const refreshed = await this.refreshToken();
            if (!refreshed) {
                console.log('‚ùå TokenÂà∑Êñ∞Â§±Ë¥•ÔºåÊ∏ÖÈô§‰ºöËØù');
                this.clearSession();
                return false;
            }
        }
        
        return true;
    }
    
    // Âà∑Êñ∞Áî®Êà∑ËµÑÊñôÊï∞ÊçÆ
    async refreshUserProfile() {
        try {
            console.log('üîÑ Âà∑Êñ∞Áî®Êà∑ËµÑÊñôÊï∞ÊçÆ...');
            const profileResult = await api.getUserProfile();
            console.log('üì° Âà∑Êñ∞Áî®Êà∑ËµÑÊñô API ÂìçÂ∫î:', profileResult);
            
            if (profileResult && profileResult.success && profileResult.data) {
                this.user = profileResult.data;
                console.log('‚úÖ Áî®Êà∑ËµÑÊñôÂà∑Êñ∞ÊàêÂäü:', this.user);
                // Êõ¥Êñ∞Êú¨Âú∞Â≠òÂÇ®
                this.saveSession(this.user, this.getCurrentToken());
                this.notifyListeners();
                return true;
            } else if (profileResult && (profileResult.id || profileResult.email)) {
                this.user = profileResult;
                console.log('‚úÖ Áî®Êà∑ËµÑÊñôÂà∑Êñ∞ÊàêÂäü (Áõ¥Êé•Ê†ºÂºè):', this.user);
                // Êõ¥Êñ∞Êú¨Âú∞Â≠òÂÇ®
                this.saveSession(this.user, this.getCurrentToken());
                this.notifyListeners();
                return true;
            } else {
                console.warn('‚ö†Ô∏è Áî®Êà∑ËµÑÊñôÂà∑Êñ∞Â§±Ë¥•ÔºåÂìçÂ∫îÊ†ºÂºèÂºÇÂ∏∏');
                return false;
            }
        } catch (error) {
            console.error('‚ùå Âà∑Êñ∞Áî®Êà∑ËµÑÊñôÂ§±Ë¥•:', error);
            return false;
        }
    }
}

// ÂàõÂª∫ÂÖ®Â±ÄËÆ§ËØÅÁÆ°ÁêÜÂô®ÂÆû‰æã
export const auth = new AuthManager();
```

### 3. API Service Layer
**File**: `src/client/js/api.js`

```javascript
import { API_CONFIG } from './config.js';

// APIÊúçÂä°Á±ª
class ApiService {
    constructor() {
        this.baseUrl = API_CONFIG.API_BASE_URL;
        this.authToken = null;
    }

    // ËÆæÁΩÆËÆ§ËØÅtoken
    setAuthToken(token) {
        this.authToken = token;
        console.log('üîë TokenÂ∑≤ËÆæÁΩÆ:', token ? 'Â≠òÂú®' : '‰∏çÂ≠òÂú®');
    }

    // ÈÄöÁî®ËØ∑Ê±ÇÊñπÊ≥ï
    async request(endpoint, options = {}) {
        const url = `${this.baseUrl}${endpoint}`;
        
        // Debug: Log token status for non-GET requests
        if ((options.method || 'GET') !== 'GET') {
            console.log('üîç API Request Debug:', {
                endpoint,
                method: options.method || 'GET',
                hasToken: !!this.authToken,
                tokenPreview: this.authToken ? `${this.authToken.substring(0, 20)}...` : 'None'
            });
        }
        
        // Check cache for GET requests
        if ((options.method || 'GET') === 'GET' && window.apiCache) {
            const cached = window.apiCache.get(url);
            if (cached) {
                logger.log(`üì¶ Cache hit: ${url}`);
                return cached;
            }
        }
        
        // ËÆæÁΩÆÈªòËÆ§headers
        const headers = {
            'Content-Type': 'application/json',
            ...options.headers
        };

        // Ê∑ªÂä†ËÆ§ËØÅtoken
        if (this.authToken) {
            headers['Authorization'] = `Bearer ${this.authToken}`;
        } else {
            console.warn('‚ö†Ô∏è No auth token available for request:', endpoint);
        }

        // Â¶ÇÊûúÊòØFormDataÔºåÁßªÈô§Content-TypeËÆ©ÊµèËßàÂô®Ëá™Âä®ËÆæÁΩÆ
        if (options.body instanceof FormData) {
            delete headers['Content-Type'];
        }

        const config = {
            method: options.method || 'GET',
            headers,
            ...options
        };

        try {
            logger.log(`üì° APIËØ∑Ê±Ç: ${config.method} ${url}`);
            const response = await fetch(url, config);
            
            logger.log(`üì° APIÂìçÂ∫î: ${response.status} ${response.statusText}`);
            
            // Â§ÑÁêÜËÆ§ËØÅÈîôËØØ
            if (response.status === 401 || response.status === 403) {
                console.error('‚ùå ËÆ§ËØÅÂ§±Ë¥•:', response.status, response.statusText);
                // Ê∏ÖÈô§Êó†ÊïàÁöÑtoken
                this.setAuthToken(null);
                localStorage.removeItem('authToken');
                localStorage.removeItem('quest_user_session');
                
                // Try to get more specific error message from response
                let errorMessage = 'ËÆ§ËØÅÂ∑≤ËøáÊúüÔºåËØ∑ÈáçÊñ∞ÁôªÂΩï';
                try {
                    const errorData = await response.json();
                    if (errorData.detail) {
                        errorMessage = errorData.detail;
                    }
                } catch (e) {
                    // If we can't parse the error response, use default message
                }
                
                throw new Error(errorMessage);
            }

            if (!response.ok) {
                const errorData = await response.json().catch(() => ({}));
                const errorMessage = errorData.detail || errorData.message || response.statusText;
                console.error('‚ùå APIÈîôËØØÂìçÂ∫î:', {
                    status: response.status,
                    statusText: response.statusText,
                    errorData: errorData,
                    errorMessage: errorMessage
                });
                throw new Error(`HTTP ${response.status}: ${errorMessage}`);
            }

            const data = await response.json();
            logger.log('‚úÖ APIÂìçÂ∫îÊàêÂäü:', data);
            
            // Cache successful GET responses
            if ((options.method || 'GET') === 'GET' && window.apiCache) {
                window.apiCache.set(url, data);
            }
            
            return data;
        } catch (error) {
            console.error('‚ùå APIËØ∑Ê±ÇÈîôËØØ:', error);
            throw error;
        }
    }

    // Ëé∑ÂèñÁî®Êà∑ÊâÄÊúâinsightsÔºà‰∏çÂàÜÈ°µÔºâ
    async getInsights(userId = null, search = '') {
        let endpoint = API_CONFIG.INSIGHTS.ALL;
        const params = new URLSearchParams();
        
        if (userId) params.append('user_id', userId);
        if (search) params.append('search', search);
        
        // Add parameter to include tags in the response
        params.append('include_tags', 'true');
        
        if (params.toString()) {
            endpoint += `?${params.toString()}`;
        }
        
        console.log('üì° Fetching insights with endpoint:', endpoint);
        return await this.request(endpoint);
    }

    // ÂàõÂª∫insight
    async createInsight(insightData) {
        return await this.request(API_CONFIG.INSIGHTS.CREATE, {
            method: 'POST',
            body: JSON.stringify(insightData)
        });
    }

    // Êõ¥Êñ∞insight
    async updateInsight(insightId, insightData) {
        return await this.request(`${API_CONFIG.INSIGHTS.UPDATE}/${insightId}`, {
            method: 'PUT',
            body: JSON.stringify(insightData)
        });
    }

    // Âà†Èô§insight
    async deleteInsight(insightId) {
        return await this.request(`${API_CONFIG.INSIGHTS.DELETE}/${insightId}`, {
            method: 'DELETE'
        });
    }

    // Ëé∑ÂèñÁî®Êà∑ËµÑÊñô
    async getUserProfile() {
        return await this.request(API_CONFIG.USER.PROFILE);
    }

    // Áî®Êà∑ÁôªÂΩï
    async login(credentials) {
        try {
            console.log('üîê ÂºÄÂßãÁî®Êà∑ÁôªÂΩï...', credentials);
            const response = await fetch(`${this.baseUrl}${API_CONFIG.AUTH.LOGIN}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(credentials)
            });

            const result = await response.json();
            console.log('üì° ÁôªÂΩïAPIÂìçÂ∫î:', result);

            if (result.success) {
                // ÂÖºÂÆπÂ§öÁßçËøîÂõûÊ†ºÂºèÔºö
                // A) { success, data: { user_id, email, access_token } }
                // B) { success, data: { user, access_token } }
                // C) { success, user, access_token }
                // D) { success, data: { success, message, data: { user, access_token } } }
                const dataLevel1 = result.data || {};
                const dataLevel2 = dataLevel1.data || {};

                const token = result.access_token 
                    || dataLevel1.access_token 
                    || dataLevel2.access_token 
                    || result.token 
                    || dataLevel1.token 
                    || dataLevel2.token 
                    || null;

                const user = result.user 
                    || dataLevel1.user 
                    || dataLevel2.user 
                    || {
                        id: dataLevel1.user_id || dataLevel2.user_id || null,
                        email: dataLevel1.email || dataLevel2.email || credentials.email
                    };

                if (token) {
                    this.setAuthToken(token);
                }

                return {
                    success: true,
                    user,
                    token
                };
            } else {
                throw new Error(result.detail || 'ÁôªÂΩïÂ§±Ë¥•');
            }
        } catch (error) {
            console.error('‚ùå ÁôªÂΩïÂ§±Ë¥•:', error);
            throw error;
        }
    }
}

// ÂàõÂª∫APIÂÆû‰æã
export const api = new ApiService();
```

### 4. Cache Management
**File**: `src/client/js/cache.js`

```javascript
// Simple in-memory cache for API responses
class ApiCache {
    constructor() {
        this.cache = new Map();
        this.ttl = 5 * 60 * 1000; // 5 minutes TTL
    }

    set(key, data) {
        this.cache.set(key, {
            data,
            timestamp: Date.now()
        });
    }

    get(key) {
        const item = this.cache.get(key);
        if (!item) return null;

        // Check if expired
        if (Date.now() - item.timestamp > this.ttl) {
            this.cache.delete(key);
            return null;
        }

        return item.data;
    }

    delete(key) {
        return this.cache.delete(key);
    }

    clear() {
        this.cache.clear();
    }

    // Clear specific patterns
    clearPattern(pattern) {
        for (const key of this.cache.keys()) {
            if (key.includes(pattern)) {
                this.cache.delete(key);
            }
        }
    }
}

// Create global cache instance
window.apiCache = new ApiCache();
```

### 5. Configuration
**File**: `src/client/js/config.js`

```javascript
// Quest Â∫îÁî®ÈÖçÁΩÆ
export const CONFIG = {
    // API ÈÖçÁΩÆ - Áõ¥Êé•‰ΩøÁî®ÂêéÁ´ØÂú∞ÂùÄ
    API_BASE_URL: 'https://quest-api-edz1.onrender.com',
    API_VERSION: 'v1',
    
    // Â∫îÁî®ÈÖçÁΩÆ
    APP_NAME: 'Quest',
    APP_DESCRIPTION: 'Curate your world',
    
    // ÂäüËÉΩÂºÄÂÖ≥
    FEATURES: {
        GOOGLE_AUTH: true,
        USER_TAGS: true,
        SHARING: true
    }
};

// APIÈÖçÁΩÆ
export const API_CONFIG = {
    // Âü∫Á°ÄURL
    API_BASE_URL: 'https://quest-api-edz1.onrender.com',
    
    // ËÆ§ËØÅÁõ∏ÂÖ≥Êé•Âè£
    AUTH: {
        REGISTER: '/api/v1/auth/signup',
        LOGIN: '/api/v1/auth/login',
        LOGOUT: '/api/v1/auth/signout',
        PROFILE: '/api/v1/auth/profile',
        FORGOT_PASSWORD: '/api/v1/auth/forgot-password'
    },
    
    // Áî®Êà∑ÁÆ°ÁêÜÊé•Âè£
    USER: {
        PROFILE: '/api/v1/user/profile',
        UPLOAD_AVATAR: '/api/v1/user/upload-avatar'
    },
    
    // ÂÖÉÊï∞ÊçÆÁõ∏ÂÖ≥Êé•Âè£
    METADATA: {
        EXTRACT: '/api/v1/metadata/extract',
        CREATE_INSIGHT: '/api/v1/metadata/create-insight'
    },
    
    // ËßÅËß£ÁÆ°ÁêÜÊé•Âè£
    INSIGHTS: {
        LIST: '/api/v1/insights',
        ALL: '/api/v1/insights/all',
        GET: '/api/v1/insights',
        CREATE: '/api/v1/insights',
        UPDATE: '/api/v1/insights',
        DELETE: '/api/v1/insights'
    },
    
    // Ê†áÁ≠æÁÆ°ÁêÜÊé•Âè£
    USER_TAGS: {
        LIST: '/api/v1/user-tags',
        GET: '/api/v1/user-tags',
        CREATE: '/api/v1/user-tags',
        UPDATE: '/api/v1/user-tags',
        DELETE: '/api/v1/user-tags',
        SEARCH: '/api/v1/user-tags/search'
    },
    
    // Â†ÜÂè†ÁÆ°ÁêÜÊé•Âè£
    STACKS: {
        LIST: '/api/v1/stacks',
        GET: '/api/v1/stacks',
        CREATE: '/api/v1/stacks',
        UPDATE: '/api/v1/stacks',
        DELETE: '/api/v1/stacks',
        ITEMS: '/api/v1/stacks/items'
    },
    
    // Á≥ªÁªüÊé•Âè£
    SYSTEM: {
        HEALTH: '/health',
        INFO: '/'
    }
};
```

## Critical Analysis Points

### 1. Data Flow Issues
- **Session Management**: 24-hour session expiration might be clearing localStorage
- **API Cache**: 5-minute TTL might serve stale data
- **localStorage Backup**: 24-hour freshness check might be too strict
- **Race Conditions**: Parallel loading might cause conflicts

### 2. Authentication Issues
- **Token Expiration**: 401/403 errors clear localStorage
- **Session Restoration**: Complex logic might fail silently
- **Token Validation**: Might trigger unnecessary data clearing

### 3. Storage Issues
- **localStorage Quota**: Might be exceeded
- **Data Corruption**: JSON parsing might fail
- **Synchronization**: Database and localStorage might be out of sync

### 4. Error Handling Issues
- **Silent Failures**: Errors might not be properly caught
- **Fallback Logic**: Might not work as expected
- **Recovery Mechanisms**: Might not be comprehensive enough

## Recommended Investigation Steps

1. **Monitor localStorage State**: Check what's actually stored
2. **Track API Calls**: Monitor all network requests
3. **Check Console Errors**: Look for JavaScript errors
4. **Test Authentication Flow**: Verify session management
5. **Test Edge Cases**: Network failures, storage limits, etc.

## Expected Outcome

The higher-level AI should identify the specific failure point and provide a targeted solution that ensures reliable data persistence across all scenarios.
